{"ast":null,"code":"import { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { createTrackingData, recordReactionAsCommitted, scheduleCleanupOfReactionIfLeaked } from \"./utils/reactionCleanupTracking\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useForceUpdate } from \"./utils/utils\";\n\nfunction observerComponentNameFor(baseComponentName) {\n  return \"observer\" + baseComponentName;\n}\n\nexport function useObserver(fn, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n\n  if (isUsingStaticRendering()) {\n    return fn();\n  }\n\n  var forceUpdate = useForceUpdate(); // StrictMode/ConcurrentMode/Suspense may mean that our component is\n  // rendered and abandoned multiple times, so we need to track leaked\n  // Reactions.\n\n  var reactionTrackingRef = React.useRef(null);\n\n  if (!reactionTrackingRef.current) {\n    // First render for this component (or first time since a previous\n    // reaction from an abandoned render was disposed).\n    var newReaction_1 = new Reaction(observerComponentNameFor(baseComponentName), function () {\n      // Observable has changed, meaning we want to re-render\n      // BUT if we're a component that hasn't yet got to the useEffect()\n      // stage, we might be a component that _started_ to render, but\n      // got dropped, and we don't want to make state changes then.\n      // (It triggers warnings in StrictMode, for a start.)\n      if (trackingData_1.mounted) {\n        // We have reached useEffect(), so we're mounted, and can trigger an update\n        forceUpdate();\n      } else {\n        // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n        // when (and if) useEffect() arrives.  The easiest way to do that is just to\n        // drop our current reaction and allow useEffect() to recreate it.\n        newReaction_1.dispose();\n        reactionTrackingRef.current = null;\n      }\n    });\n    var trackingData_1 = createTrackingData(newReaction_1);\n    reactionTrackingRef.current = trackingData_1;\n    scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);\n  }\n\n  var reaction = reactionTrackingRef.current.reaction;\n  React.useDebugValue(reaction, printDebugValue);\n  React.useEffect(function () {\n    // Called on first mount only\n    recordReactionAsCommitted(reactionTrackingRef);\n\n    if (reactionTrackingRef.current) {\n      // Great. We've already got our reaction from our render;\n      // all we need to do is to record that it's now mounted,\n      // to allow future observable changes to trigger re-renders\n      reactionTrackingRef.current.mounted = true;\n    } else {\n      // The reaction we set up in our render has been disposed.\n      // This is either due to bad timings of renderings, e.g. our\n      // component was paused for a _very_ long time, and our\n      // reaction got cleaned up, or we got a observable change\n      // between render and useEffect\n      // Re-create the reaction\n      reactionTrackingRef.current = {\n        reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n          // We've definitely already been mounted at this point\n          forceUpdate();\n        }),\n        cleanAt: Infinity\n      };\n      forceUpdate();\n    }\n\n    return function () {\n      reactionTrackingRef.current.reaction.dispose();\n      reactionTrackingRef.current = null;\n    };\n  }, []); // render the original component, but have the\n  // reaction track the observables, so that rendering\n  // can be invalidated (see above) once a dependency changes\n\n  var rendering;\n  var exception;\n  reaction.track(function () {\n    try {\n      rendering = fn();\n    } catch (e) {\n      exception = e;\n    }\n  });\n\n  if (exception) {\n    throw exception; // re-throw any exceptions caught during rendering\n  }\n\n  return rendering;\n}","map":{"version":3,"sources":["/Volumes/9/mine/code/reactMobx/reactmobx/node_modules/mobx-react-lite/es/useObserver.js"],"names":["Reaction","React","printDebugValue","createTrackingData","recordReactionAsCommitted","scheduleCleanupOfReactionIfLeaked","isUsingStaticRendering","useForceUpdate","observerComponentNameFor","baseComponentName","useObserver","fn","forceUpdate","reactionTrackingRef","useRef","current","newReaction_1","trackingData_1","mounted","dispose","reaction","useDebugValue","useEffect","cleanAt","Infinity","rendering","exception","track","e"],"mappings":"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","sourcesContent":["import { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { createTrackingData, recordReactionAsCommitted, scheduleCleanupOfReactionIfLeaked } from \"./utils/reactionCleanupTracking\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useForceUpdate } from \"./utils/utils\";\nfunction observerComponentNameFor(baseComponentName) {\n    return \"observer\" + baseComponentName;\n}\nexport function useObserver(fn, baseComponentName) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (isUsingStaticRendering()) {\n        return fn();\n    }\n    var forceUpdate = useForceUpdate();\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    var reactionTrackingRef = React.useRef(null);\n    if (!reactionTrackingRef.current) {\n        // First render for this component (or first time since a previous\n        // reaction from an abandoned render was disposed).\n        var newReaction_1 = new Reaction(observerComponentNameFor(baseComponentName), function () {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (trackingData_1.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                forceUpdate();\n            }\n            else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.  The easiest way to do that is just to\n                // drop our current reaction and allow useEffect() to recreate it.\n                newReaction_1.dispose();\n                reactionTrackingRef.current = null;\n            }\n        });\n        var trackingData_1 = createTrackingData(newReaction_1);\n        reactionTrackingRef.current = trackingData_1;\n        scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);\n    }\n    var reaction = reactionTrackingRef.current.reaction;\n    React.useDebugValue(reaction, printDebugValue);\n    React.useEffect(function () {\n        // Called on first mount only\n        recordReactionAsCommitted(reactionTrackingRef);\n        if (reactionTrackingRef.current) {\n            // Great. We've already got our reaction from our render;\n            // all we need to do is to record that it's now mounted,\n            // to allow future observable changes to trigger re-renders\n            reactionTrackingRef.current.mounted = true;\n        }\n        else {\n            // The reaction we set up in our render has been disposed.\n            // This is either due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up, or we got a observable change\n            // between render and useEffect\n            // Re-create the reaction\n            reactionTrackingRef.current = {\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n                    // We've definitely already been mounted at this point\n                    forceUpdate();\n                }),\n                cleanAt: Infinity\n            };\n            forceUpdate();\n        }\n        return function () {\n            reactionTrackingRef.current.reaction.dispose();\n            reactionTrackingRef.current = null;\n        };\n    }, []);\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    var rendering;\n    var exception;\n    reaction.track(function () {\n        try {\n            rendering = fn();\n        }\n        catch (e) {\n            exception = e;\n        }\n    });\n    if (exception) {\n        throw exception; // re-throw any exceptions caught during rendering\n    }\n    return rendering;\n}\n"]},"metadata":{},"sourceType":"module"}